/**
 * На стандартном потоке ввода задается целое неотрицательное число N и
 * последовательность допустимых символов в кодировке ASCII,
 * оканчивающаяся точкой. Допустимые символы – латинские буквы 'a' ... 'z', 'A' ...
 * 'Z' и пробел. Требуется закодировать латинские буквы ('a' ... 'z', 'A' ... 'Z')
 * шифром Цезаря, пробелы вывести без изменения. Число N задает сдвиг в
 * шифре. Шифр Цезаря заключается в следующем преобразовании. Пусть буквы
 * алфавита пронумерованы от 0 до K - 1, где K - число символов в алфавите.
 * Тогда символ с номером n кодируется символом с номером p = (n + N) mod K
 * (mod - операция взятия остатка). На стандартном потоке вывода напечатать
 * зашифрованное сообщение, оканчивающееся точкой. Преобразование
 * требуется выполнять независимо для заглавных и строчных латинских букв.
 * 
 * Указание: использовать массивы запрещается.
 * **/

#include <stdio.h>
#include <stdbool.h>

int main() {
    unsigned shift;
    if (1 != scanf("%u", &shift)) {
        fprintf(stderr, "Can't read shift number from stdin\n");
        return 1;
    }

    char next_char;
    bool skip_space = true;

    while (1) {
        if (1 != scanf("%c", &next_char)) {
            fprintf(stderr, "Unexpected end of stdin\n");
            return 1;
        }

        /**
         * Этот кусочек кода позволяет пропустить ведующие 
         * пробелы между числом и первым непробельным символом.
         * Например: 
         * 1       Hello World!.
         * Ifmmp Xpsme!.
         */
        if (skip_space && ' ' == next_char)
            continue;

        skip_space = false;

        if ('a' <= next_char && 'z' >= next_char)
            next_char = (next_char - 'a' + shift) % 26 + 'a';

        if ('A' <= next_char && 'Z' >= next_char)
            next_char = (next_char - 'A' + shift) % 26 + 'A';

        printf("%c", next_char);

        if ('.' == next_char)
            break;        
    }

    return 0;
}